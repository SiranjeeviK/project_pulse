import 'package:project_pulse/core/error/exception.dart';
import 'package:project_pulse/core/utils/generate_unique_attendance_id.dart';
import 'package:project_pulse/features/attendance/data/models/attendance_model.dart';
import 'package:project_pulse/features/attendance/domain/entities/student_attendance.dart';
import 'package:project_pulse/features/attendance/domain/usecases/mark_attendance.dart';
import 'package:project_pulse/features/main/data/models/course_class_faculty_mapping_model.dart';
import 'package:project_pulse/features/main/data/models/course_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

abstract interface class AttendanceRemoteDataSource {
  Future<List<AttendanceModel>> markAttendance(
      MarkAttendanceParams markAttendanceParams);
}

class AttendanceRemoteDataSourceImpl implements AttendanceRemoteDataSource {
  final SupabaseClient supabaseClient;

  AttendanceRemoteDataSourceImpl({required this.supabaseClient});
  // create table
  // public.attendance (
  //   date date not null,
  //   status text null,
  //   roll_number text null,
  //   remarks text null,
  //   substitute_faculty_id uuid null,
  //   mapping_id bigint null,
  //   attendance_id text not null,
  //   constraint attendance_pkey primary key (attendance_id),
  //   constraint attendance_unique_attendance_id_key unique (attendance_id),
  //   constraint attendance_mapping_id_fkey foreign key (mapping_id) references course_class_faculty_mapping (mapping_id) on update cascade on delete restrict,
  //   constraint attendance_roll_number_fkey foreign key (roll_number) references students (roll_number) on update cascade on delete restrict,
  //   constraint attendance_substitute_faculty_id_fkey foreign key (substitute_faculty_id) references faculty (faculty_id) on update restrict on delete restrict,
  //   constraint attendance_status_check check (
  //     (
  //       status = any (
  //         array[
  //           'present'::text,
  //           'absent'::text,
  //           'late'::text,
  //           'on_duty'::text
  //         ]
  //       )
  //     )
  //   )
  // ) tablespace pg_default;

// create table
//   public.course_class_faculty_mapping (
//     course_code text not null,
//     class_code text not null,
//     faculty_id uuid not null,
//     mapping_id integer generated by default as identity,
//     semester integer null,
//     constraint course_class_faculty_mapping_pkey primary key (mapping_id),
//     constraint course_class_faculty_mapping_class_code_fkey foreign key (class_code) references classes (class_code) on update cascade on delete cascade,
//     constraint course_class_faculty_mapping_course_code_fkey foreign key (course_code) references courses (course_code) on update cascade on delete cascade,
//     constraint course_class_faculty_mapping_faculty_id_fkey foreign key (faculty_id) references faculty (faculty_id) on update cascade on delete cascade
//   ) tablespace pg_default;

  @override
  Future<List<AttendanceModel>> markAttendance(
      MarkAttendanceParams markAttendanceParams) async {
    try {
      print(
          '[from attendance_remote_datasource.dart] markAttendanceParams: $markAttendanceParams');
      if (markAttendanceParams.facultyId == null &&
          markAttendanceParams.substituteFacultyId == null) {
        throw const ServerException(
            'Both faculty and substitute faculty cannot be null');
      }

      final mappingResponse = await supabaseClient
          .from('course_class_faculty_mapping')
          .select()
          .eq('mapping_id', markAttendanceParams.mapppingId);
      if (mappingResponse.isEmpty) {
        throw const ServerException(
            'Mapping not found'); //which means faculty is not assigned to this class for this course
      }

      final mappingData = CourseClassFacultyMappingModel.fromMap(mappingResponse
          .first); //now we got course, class and faculty details from mapping
      print(
          '[from attendance_remote_datasource.dart] mappingData: $mappingData');

      // if (mappingData.facultyId != markAttendanceParams.facultyId) {
      //   throw const ServerException('Faculty not assigned to this class');
      // }

      final courseResponse = await supabaseClient
          .from('courses')
          .select()
          .eq('course_code', mappingData.courseCode);
      if (courseResponse.isEmpty) {
        throw const ServerException('Course not found');
      }

      final course = CourseModel.fromMap(courseResponse.first);

      print('[from attendance_remote_datasource.dart] course: $course');

      final List<AttendanceModel> attendences = [];
      for (StudentAttendance studentAttendance
          in markAttendanceParams.studentAttendances) {
        final response = await supabaseClient.from('attendance').upsert([
          {
            'attendance_id': generateUniqueAttendanceId(
                markAttendanceParams.date,
                markAttendanceParams.nthPeriod,
                markAttendanceParams.mapppingId,
                studentAttendance.rollNo),
            'date': markAttendanceParams.date.toIso8601String(),
            'status': studentAttendance.status,
            'roll_number': studentAttendance.rollNo,
            'remarks': markAttendanceParams.remarks,
            'substitute_faculty_id': markAttendanceParams.substituteFacultyId,
            'mapping_id': markAttendanceParams.mapppingId,
          }
        ]).select();

        attendences.add(AttendanceModel.fromMap(response.first));
      }
      print(
          '[from attendance_remote_datasource.dart] attendences: $attendences');
      return attendences;
    } on PostgrestException catch (e) {
      throw ServerException(e.message);
    } catch (e) {
      throw ServerException(e.toString());
    }
  }
}
