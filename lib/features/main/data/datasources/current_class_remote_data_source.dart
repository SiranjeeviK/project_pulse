import 'package:project_pulse/core/constants/constants.dart';
import 'package:project_pulse/core/error/exception.dart';
import 'package:project_pulse/features/auth/data/datasources/auth_remote_data_source.dart';
import 'package:project_pulse/features/main/data/models/course_class_faculty_mapping_model.dart';
import 'package:project_pulse/features/main/domain/entities/current_class.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

import 'package:supabase_flutter/supabase_flutter.dart';

abstract interface class CurrentClassRemoteDataSource {
  Future<CurrentClass> getCurrentClasses();
}

class CurrentClassRemoteDataSourceImpl implements CurrentClassRemoteDataSource {
  final SupabaseClient supabaseClient;
  final AuthRemoteDataSource authRemoteDataSource;
  CurrentClassRemoteDataSourceImpl(
      {required this.supabaseClient, required this.authRemoteDataSource});

  @override
  Future<CurrentClass> getCurrentClasses() async {
    try {
      final response = await http.get(
        Uri.parse(Constants.getItBTimeTableUrl()),
        headers: {
          'Content-Type': 'application/json',
        },
      );

      if (response.statusCode == 200) {
        List<dynamic> partialData = json.decode(response.body);
        String? courseCode =
            Constants.itbSem4SubjectToCourseCode[partialData[0]];
        int mappingId = await _getMappingId(courseCode) ?? 0;
        List<dynamic> data = [...partialData, courseCode, mappingId];
        final currentClassData = CurrentClass.fromList(data);
        print(currentClassData);
        return currentClassData;
      } else {
        throw const ServerException('Unable to fetch current classes');
      }
    } catch (e) {
      throw ServerException(e.toString());
    }
  }

  Future<int?> _getMappingId(String? courseCode) async {
    if (courseCode == null || courseCode == '') return null;

    //   create table
    // public.course_class_faculty_mapping (
    //   course_code text not null,
    //   class_code text not null,
    //   faculty_id uuid not null,
    //   mapping_id integer generated by default as identity,
    //   semester integer null,
    //   constraint course_class_faculty_mapping_pkey primary key (mapping_id),
    //   constraint course_class_faculty_mapping_class_code_fkey foreign key (class_code) references classes (class_code) on update cascade on delete cascade,
    //   constraint course_class_faculty_mapping_course_code_fkey foreign key (course_code) references courses (course_code) on update cascade on delete cascade,
    //   constraint course_class_faculty_mapping_faculty_id_fkey foreign key (faculty_id) references faculty (faculty_id) on update cascade on delete cascade
    // ) tablespace pg_default;

    final userData = await authRemoteDataSource.getCurrentUserData();
    final query = supabaseClient
        .from('course_class_faculty_mapping')
        .select('mapping_id')
        .eq('course_code', courseCode);

    if (userData == null) return null;
    if (userData.isStudent) {
      final response = await query.eq('class_code', userData.classCode);
      final data = CourseClassFacultyMappingModel.fromMap(response.first);
      return data.mappingId;
    } else if (userData.isFaculty) {
      final response = await query.eq('faculty_id', userData.id);
      final data = CourseClassFacultyMappingModel.fromMap(response.first);
      return data.mappingId;
    } else {
      throw const ServerException(
          '[From current class remote data source] User is neither student nor faculty');
    }
  }
}
